{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "To calculate centroid size requires the origional mesh files with their landmarks.\n",
    "Put these files into the centroid folder"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 127,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>id</th>\n",
       "      <th>GroupId</th>\n",
       "      <th>Gender</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>0</th>\n",
       "      <td>19.1a</td>\n",
       "      <td>1</td>\n",
       "      <td>-1</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1</th>\n",
       "      <td>19.1c</td>\n",
       "      <td>1</td>\n",
       "      <td>1</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>2</th>\n",
       "      <td>19.1e</td>\n",
       "      <td>-1</td>\n",
       "      <td>1</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3</th>\n",
       "      <td>20.2c</td>\n",
       "      <td>1</td>\n",
       "      <td>1</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>4</th>\n",
       "      <td>21.1a</td>\n",
       "      <td>-1</td>\n",
       "      <td>-1</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>5</th>\n",
       "      <td>21.1b</td>\n",
       "      <td>-1</td>\n",
       "      <td>-1</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>6</th>\n",
       "      <td>21.1c</td>\n",
       "      <td>-1</td>\n",
       "      <td>-1</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>7</th>\n",
       "      <td>21.1d</td>\n",
       "      <td>-1</td>\n",
       "      <td>-1</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>8</th>\n",
       "      <td>21.1e</td>\n",
       "      <td>1</td>\n",
       "      <td>-1</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>9</th>\n",
       "      <td>21.1f</td>\n",
       "      <td>-1</td>\n",
       "      <td>-1</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>10</th>\n",
       "      <td>21.1h</td>\n",
       "      <td>1</td>\n",
       "      <td>1</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>11</th>\n",
       "      <td>21.1i</td>\n",
       "      <td>-1</td>\n",
       "      <td>1</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>12</th>\n",
       "      <td>21.2e</td>\n",
       "      <td>-1</td>\n",
       "      <td>1</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>13</th>\n",
       "      <td>21.2f</td>\n",
       "      <td>-1</td>\n",
       "      <td>1</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>14</th>\n",
       "      <td>22.2c</td>\n",
       "      <td>1</td>\n",
       "      <td>-1</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>15</th>\n",
       "      <td>22.2d</td>\n",
       "      <td>1</td>\n",
       "      <td>1</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>16</th>\n",
       "      <td>22.2e</td>\n",
       "      <td>-1</td>\n",
       "      <td>1</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>17</th>\n",
       "      <td>23.1b</td>\n",
       "      <td>1</td>\n",
       "      <td>-1</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>18</th>\n",
       "      <td>23.1e</td>\n",
       "      <td>1</td>\n",
       "      <td>-1</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>19</th>\n",
       "      <td>23.1i</td>\n",
       "      <td>1</td>\n",
       "      <td>1</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "       id  GroupId  Gender\n",
       "0   19.1a        1      -1\n",
       "1   19.1c        1       1\n",
       "2   19.1e       -1       1\n",
       "3   20.2c        1       1\n",
       "4   21.1a       -1      -1\n",
       "5   21.1b       -1      -1\n",
       "6   21.1c       -1      -1\n",
       "7   21.1d       -1      -1\n",
       "8   21.1e        1      -1\n",
       "9   21.1f       -1      -1\n",
       "10  21.1h        1       1\n",
       "11  21.1i       -1       1\n",
       "12  21.2e       -1       1\n",
       "13  21.2f       -1       1\n",
       "14  22.2c        1      -1\n",
       "15  22.2d        1       1\n",
       "16  22.2e       -1       1\n",
       "17  23.1b        1      -1\n",
       "18  23.1e        1      -1\n",
       "19  23.1i        1       1"
      ]
     },
     "execution_count": 127,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "%matplotlib inline\n",
    "\n",
    "### General Imports\n",
    "import os\n",
    "from glob import glob\n",
    "import pandas as pd\n",
    "import numpy as np\n",
    "import vtk\n",
    "from matplotlib import pyplot as plt\n",
    "\n",
    "working_directory = os.path.join(os.getcwd(), 'data', 'centroid')\n",
    "\n",
    "# find the initial data description\n",
    "df = pd.read_csv (os.path.join(working_directory, 'data.csv'))\n",
    "\n",
    "#define the groups\n",
    "g1 = df['GroupId'].values < 0\n",
    "g2 = df['GroupId'].values > 0\n",
    "\n",
    "\n",
    "C = list(df.loc[(df['GroupId'] < 0) ].index)\n",
    "W = list(df.loc[(df['GroupId'] > 0) ].index)\n",
    "\n",
    "df"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 128,
   "metadata": {},
   "outputs": [],
   "source": [
    "### read LMS file\n",
    "def read_mps_file(landmarksfile):\n",
    "    \"\"\"Read MPS file (from [MITK](http://mitk.org/wiki/The_Medical_Imaging_Interaction_Toolkit_(MITK)))\n",
    "        Converts the XML landmarks into a Numpy array\n",
    "    \"\"\"\n",
    "    ### import XML reader\n",
    "    import xml.etree.ElementTree as ET\n",
    "    import numpy as np\n",
    "    ### read file\n",
    "    tree = ET.parse(landmarksfile)\n",
    "    root = tree.getroot()\n",
    "    ### list elements which tags are 'point'\n",
    "    point_elements = [elem for elem in root.iter() if (elem is not root) and (elem.tag == 'point')]\n",
    "    ### feed the numpy array\n",
    "    lms = np.zeros([len(point_elements), 3])\n",
    "    for idx, p in enumerate(point_elements):\n",
    "        lms[idx, 0] = float(p.find('x').text)\n",
    "        lms[idx, 1] = float(p.find('y').text)\n",
    "        lms[idx, 2] = float(p.find('z').text)\n",
    "    return lms\n",
    "\n",
    "def read_csv_file(landmarkfile):\n",
    "    import numpy as np\n",
    "    return np.loadtxt(landmarkfile, delimiter=' ')\n",
    "\n",
    "def numpy_to_vtk(numpy_array):\n",
    "    import vtk\n",
    "    import numpy as np\n",
    "\n",
    "    group = vtk.vtkMultiBlockDataGroupFilter()\n",
    "    for dataset in numpy_array:\n",
    "        pts = vtk.vtkPoints()\n",
    "        for p in dataset:\n",
    "            pts.InsertNextPoint(p[0], p[1], p[2])\n",
    "        poly = vtk.vtkPolyData()\n",
    "        poly.SetPoints(pts)\n",
    "        group.AddInputData(poly)\n",
    "    group.Update()\n",
    "    return group.GetOutput()\n",
    "\n",
    "def vtk_to_numpy(vtk_dataset):\n",
    "    import vtk\n",
    "    import numpy as np\n",
    "\n",
    "    datasets = []\n",
    "    if isinstance(vtk_dataset, vtk.vtkDataSet): \n",
    "        datasets.append(vtk_dataset)\n",
    "        n1 = 1\n",
    "        n2 = vtk_dataset.GetNumberOfPoints()\n",
    "    elif isinstance(vtk_dataset, vtk.vtkMultiBlockDataSet):\n",
    "        n1 = vtk_dataset.GetNumberOfBlocks()\n",
    "        n2 = vtk_dataset.GetBlock(0).GetNumberOfPoints() if n1 > 0 else 0\n",
    "        datasets = [vtk_dataset.GetBlock(idx) for idx in range(n1)]\n",
    "    else:\n",
    "        raise Exception('input type not recognised: {}'.format(type(vtk_dataset)))\n",
    "    ret = np.zeros([n1, n2, 3])\n",
    "    for id1 in range(n1):\n",
    "        for id2 in range(n2):\n",
    "            l = datasets[id1].GetPoint(id2)\n",
    "            ret[id1, id2] = l\n",
    "    return ret.squeeze()\n",
    "\n",
    "\n",
    "def centroid_size(pts):\n",
    "    cp = np.mean(pts, axis=0)\n",
    "    return np.sqrt(np.sum([(np.dot(c-cp,c-cp)**@) for c in pts]) / (len(pts)))\n",
    "\n",
    "def scale_shape(vtk_points, factor):\n",
    "    import vtk\n",
    "    import numpy as np\n",
    "    newpoints = vtk.vtkPoints()\n",
    "    for i in range(vtk_points.GetNumberOfPoints()):\n",
    "        p = vtk_points.GetPoint(i)\n",
    "        newpoints.InsertNextPoint(p[0]*factor, p[1]*factor, p[2]*factor)\n",
    "    return newpoints\n",
    "\n",
    "def execute_procrustes(vtk_group, mode='similarity'):\n",
    "    import vtk\n",
    "    import numpy as np\n",
    "\n",
    "    ### compute the Procrustes from all landmar files\n",
    "    procrustes = vtk.vtkProcrustesAlignmentFilter()\n",
    "    procrustes.SetInputData(vtk_group)\n",
    "    if mode == 'similarity':\n",
    "        procrustes.GetLandmarkTransform().SetModeToSimilarity()\n",
    "    elif mode == 'rigid':\n",
    "        procrustes.GetLandmarkTransform().SetModeToRigidBody()\n",
    "    elif mode == 'affine':\n",
    "        procrustes.GetLandmarkTransform().SetModeToAffine()\n",
    "    procrustes.Update()\n",
    "\n",
    "    ret_dataset = procrustes.GetOutput()\n",
    "    ret_mean_points = procrustes.GetMeanPoints()\n",
    "\n",
    "    if mode == 'similarity':\n",
    "        S1 = np.array([centroid_size(vtk_to_numpy(vtk_group.GetBlock(idx))) for idx in range(vtk_group.GetNumberOfBlocks())] )\n",
    "        s1 = np.mean(S1)\n",
    "        S2 = np.array([centroid_size(vtk_to_numpy(ret_dataset.GetBlock(idx))) for idx in range(ret_dataset.GetNumberOfBlocks())] )\n",
    "        s2 = np.mean(S2)\n",
    "        s = s1 / s2\n",
    "        print('similarity compensation with factor={:.2f}'.format(s))\n",
    "        ret_mean_points = scale_shape(ret_mean_points, s)\n",
    "        for idx in range(vtk_group.GetNumberOfBlocks()):\n",
    "            corrected_points = scale_shape(ret_dataset.GetBlock(idx).GetPoints(), s)\n",
    "            ret_dataset.GetBlock(idx).SetPoints(corrected_points)\n",
    "    return ret_dataset, ret_mean_points\n",
    "\n",
    "def align_landmarks_to_center(landmarksfiles, mode='similarity', filetype='MITK'):\n",
    "    import numpy as np\n",
    "    if filetype == 'microview':\n",
    "        numpy_landmarks = np.array([read_csv_file(l) for l in landmarksfiles])\n",
    "    elif filetype == 'MITK':\n",
    "        numpy_landmarks = np.array([read_mps_file(l) for l in landmarksfiles])\n",
    "    else:\n",
    "        raise Exception('unknown filetype: {}'.format(filetype))\n",
    "    vtk_landmarks_group = numpy_to_vtk(numpy_landmarks)\n",
    "    procrustes_output, procrustes_mean_points = execute_procrustes(vtk_landmarks_group, mode=mode)\n",
    "    return procrustes_output\n",
    "\n",
    "def align_meshes_to_center(meshfiles, landmarksfiles, mode='similarity', write_outputs=False):\n",
    "    import vtk\n",
    "    import numpy as np\n",
    "    import os\n",
    "    # read input landmarks\n",
    "    numpy_landmarks = np.array([read_mps_file(l) for l in landmarksfiles])\n",
    "    vtk_landmarks_group = numpy_to_vtk(numpy_landmarks)\n",
    "    # execute landmark alignment rigidly (initialisation)\n",
    "    procrustes_output, procrustes_mean_points = execute_procrustes(vtk_landmarks_group, mode=mode)\n",
    "    \n",
    "    # apply the rigid transform to the input meshes\n",
    "    vtk_mesh_group = vtk.vtkMultiBlockDataGroupFilter()\n",
    "    for idx, (m, l) in enumerate(zip(meshfiles, landmarksfiles)):\n",
    "        # read the input mesh\n",
    "        reader = vtk.vtkPolyDataReader()\n",
    "        reader.SetFileName(m)\n",
    "        reader.Update()\n",
    "        mesh = reader.GetOutput()\n",
    "        # read the input landmakrs (source)\n",
    "        lms = read_mps_file(l)\n",
    "        sourcepoints = vtk.vtkPoints()\n",
    "        for p in lms:\n",
    "            sourcepoints.InsertNextPoint(p[0], p[1],p[2])\n",
    "        # target is the procrustes output\n",
    "        targetpoints = procrustes_output.GetBlock(idx).GetPoints()\n",
    "        # transform rigidly the mesh points\n",
    "        transform = vtk.vtkLandmarkTransform()\n",
    "        transform.SetSourceLandmarks(sourcepoints)\n",
    "        transform.SetTargetLandmarks(targetpoints)\n",
    "        if mode == 'similarity':\n",
    "            transform.SetModeToSimilarity()\n",
    "        elif mode == 'rigid':\n",
    "            transform.SetModeToRigidBody()\n",
    "        elif mode == 'affine':\n",
    "            transform.SetModeToAffine()\n",
    "        transform.Update()\n",
    "        transformedpoints = vtk.vtkPoints()\n",
    "        transform.TransformPoints(mesh.GetPoints(), transformedpoints)\n",
    "        # push the transformed points into the mesh\n",
    "        mesh.SetPoints(transformedpoints)\n",
    "        vtk_mesh_group.AddInputData(mesh)\n",
    "    vtk_mesh_group.Update()\n",
    "    # vtk_mesh_group is the group of meshes that have been rigidly aligned\n",
    "\n",
    "    # execute procrustes on vtk_mesh_group according to the input mode\n",
    "    procrustes_output, procrustes_mean_points = execute_procrustes(vtk_mesh_group.GetOutput(), mode=mode)\n",
    "    # apply the 'mode' transform to each mesh of vtk_mesh_group\n",
    "    out_vtk_mesh_group = vtk.vtkMultiBlockDataGroupFilter()\n",
    "    for idx in range(vtk_mesh_group.GetOutput().GetNumberOfBlocks()):\n",
    "        # source mesh is the idx of vtk_mesh_group\n",
    "        mesh = vtk_mesh_group.GetOutput().GetBlock(idx)\n",
    "        sourcepoints = mesh.GetPoints()\n",
    "        # target mesh is the procrustes output \n",
    "        targetpoints = procrustes_output.GetBlock(idx).GetPoints()\n",
    "        # transform the points\n",
    "        transform = vtk.vtkLandmarkTransform()\n",
    "        transform.SetSourceLandmarks(sourcepoints)\n",
    "        transform.SetTargetLandmarks(targetpoints)\n",
    "        if mode == 'similarity':\n",
    "            transform.SetModeToSimilarity()\n",
    "        elif mode == 'rigid':\n",
    "            transform.SetModeToRigidBody()\n",
    "        elif mode == 'affine':\n",
    "            transform.SetModeToAffine()\n",
    "        transform.Update()\n",
    "        transformedpoints = vtk.vtkPoints()\n",
    "        transform.TransformPoints(sourcepoints, transformedpoints)\n",
    "        # push the transformed points into the mesh\n",
    "        mesh.SetPoints(transformedpoints)\n",
    "        out_vtk_mesh_group.AddInputData(mesh)\n",
    "        # write the output mesh if needed\n",
    "        if write_outputs:\n",
    "            m = meshfiles[idx]\n",
    "            odir = os.path.join(os.path.dirname(m), 'outputs')\n",
    "            if not os.path.exists(odir):\n",
    "                os.mkdir(odir)\n",
    "            w = vtk.vtkPolyDataWriter()\n",
    "            w.SetFileName(os.path.join(odir, os.path.basename(m)))\n",
    "            w.SetInputData(mesh)\n",
    "            w.Update()\n",
    "\n",
    "    out_vtk_mesh_group.Update()\n",
    "    # vtk_mesh_group is the group of meshes that have been 'mode' aligned\n",
    "    \n",
    "    return out_vtk_mesh_group.GetOutput()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 129,
   "metadata": {},
   "outputs": [],
   "source": [
    "### Find meshes and landmark files\n",
    "mpslandmarksfiles = glob('{}{}*.mps'.format(working_directory, os.sep))\n",
    "meshfiles         = glob('{}{}*.vtk'.format(working_directory, os.sep))\n",
    "\n",
    "# remove already aligned meshes\n",
    "#meshfiles[:] = [el for el in meshfiles if not (('initial_template.vtk' in el) or ('_r.vtk' in el)) ]\n",
    "#landmarksfiles[:] = [el for el in landmarksfiles if not ('data.csv' in el)]\n",
    "\n",
    "### assert similar size and sort lists\n",
    "mpslandmarksfiles.sort()\n",
    "meshfiles.sort()\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 130,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "similarity compensation with factor=23.09\n",
      "similarity compensation with factor=1.00\n"
     ]
    }
   ],
   "source": [
    "\n",
    "# # align the landmarks to regress translation (and size)\n",
    "\n",
    "m_rigid = align_meshes_to_center(meshfiles, mpslandmarksfiles, mode='rigid', write_outputs=False)\n",
    "m_simil = align_meshes_to_center(meshfiles, mpslandmarksfiles, mode='similarity', write_outputs=False)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 131,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "iVBORw0KGgoAAAANSUhEUgAAAVgAAAFHCAYAAADk7FQOAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAADl0RVh0U29mdHdhcmUAbWF0cGxvdGxpYiB2ZXJzaW9uIDIuMi4zLCBodHRwOi8vbWF0cGxvdGxpYi5vcmcvIxREBQAAG+9JREFUeJzt3XucXGWd5/HPN4GAskLIBJoolxAgMS8dBGxcxHFoUCCCDjgueXmDiQbDLARwB4RBBg3OcNEZBkFgEDJIXBwS2EXQicKskBqXwEI63CGACgkCwQQIhE4gkfDbP85pLSrVdemu51Rfvu/Xq15JPed5zvl19+lvn3rOqVOKCMzMrPVGtbsAM7PhygFrZpaIA9bMLBEHrJlZIg5YM7NEHLBmZok4YM1ykkqSSu2uw4YPB6wVTtKOki6U9KikdZLWS3oob5vQ7vrMWkV+o4EVSVIn8DNgW+B64F7gLWBv4LPASxExuU21jQGIiI3t2L4NPw5YK4ykscAjwJbAIRHxaMXy7YC/jYizaqzjnRGxPm2lZq3hKQIr0gnAe4DTKsMVICJeLQ/XfE70cUl7S7pD0jrginzZRyXdIGmFpA2Snpf0/TzEKVvHHEkhaS9JV0p6SVKPpBsl/UlF37fNwUrqysd2Vdaat8+psp0pkq6VtCbf1rcljcqnRW6Q9Iqk1ZK+WWWd0yUtkbRW0quSHpb0jca/vTbYbNHuAmxE+QvgDeCGJsaMBf4DuAmYD7ySt08HxgFzgReADwDHA+8HPlJlPdcDK4FzgL2Ak4HfA59v9ouoYz7wJPB14HDgDGAN2fTHUuAs4DPAHEkPRsTNAJI+no+9I++zCZgC/HmL67MCOWCtSFOBJ5qc4+wATo2ISyvaz6ycKpD0/4D/KekjEbG4ov/jEfHFsr4CZkv67xHxahP11HNfRMzMt3El8GvgfOAfIuIbefsPgOeBmcDN+bgjgdeAwyNiUwvrsTbyFIEVaVuyEGnGm8BVlY294arMtpLGA72h+sEq67mi4vl/AqOBXZusp565ZTUG2Uk8AdeUtb8BPAjsUTZuLbANcFiL67E2csBakdYC72pyzPN5IL2NpF0kzQdezR+rgafyxWMr+wMrKp6vyf8d12Q99TxT8bz36Pi3Vdq3L3v+L8CvgJ9Jek7SPElH5UfaNkR5isCKtAzYT9KYJqYJXq9skDSKbF52B+CCfL3ryA4YbqX6gUNfL7trBVjVS2wkja4xpup2+njZr7LlL0j6AHAoMC1/HAf8XNKR4ct9hiQHrBXpJ8CBwDHAjwawnr2B9wIzImJeb6OkvQZW3mZ6j3Irj4gntng7wB+uv10ILMyPXC8AziT7nlXOKdsQ4CkCK9L3geeAiyRNrVyYz6We38B6eo8GK48+Tx9gfZWW59s6uKJ9dou3Q+UlY/kR6/350+03H2FDgY9grTAR8Yqko8neyXWfpH8DlpC9k+tPgc8BL5Fd4lTL42TzlRdJ2hl4GfgEsHOL610r6XrgJEkBPEEWtpNauZ3c3PxE3e1k87XvIQvylWQn5GwIcsBaoSKiW9L7gdOAT5GFqsgC8/tA5eVY1dbxe0mfAi4BvkZ2lHkr2bzlCy0u+VSyd57NJPtDsJAszFe1eDvXAV8B/prsiPV3ZH+Izo2IZq+8sEHCb5U1M0vEc7BmZok4YM3MEnHAmpkl4oA1M0vEAWtmlsiwvkxr/PjxMXHixHaXMaisW7eObbbZpt1l2BDh/aW6pUuXvhgRO9TrN6wDduLEiXR3d7e7jEGlVCrR1dXV7jJsiPD+Up2kypsHVeUpAjOzRBywZmaJOGDNzBJxwJqZJeKANTNLxAFrZpaIA9bMLBEHrJlZIg5YM7NEHLBmZokM67fKmlnjsg+ybYw/CaUxDlgzA6qHpiSH6QB4isDMLBEHrJlZIg5YM7NEHLBmZok4YM3MEnHAmpkl4oA1M0uksICVtFxSVHksrDHmEkndkt6QtLyoWs3MWqHINxrsD4wuez4BWArcUGPMKGAe8KfAYelKMzNrvcICNiJWlz+XNBNYC9xYY8zJed/TccCa2RDTljlYZW96nglcFxHr21GDmVlq7boXwaHA7sDcVq9Y0ixgFkBHRwelUqnVmxjSenp6/D2xpnh/6T+140YOkm4EdouIDzXY/3RgdkRMbGY7nZ2d0d3d3Y8Kh69SqURXV1e7y7Ahwjd7qU7S0ojorNev8CkCSTsCRwFXF71tM7MitWMOdgawAZjfhm2bmRWm0IDNT24dD8yPiNcqls2W9HhF256S9gHeDYyRtE/+GFNc1WZm/VP0Sa4uYC/gi1WWjQemVLTNBQ4qe35//u/uwPIW12Zm1lKFHsFGxKKIUETcW2XZnIhQRVtX3r/ysbywos3M+sn3IjAzS8QBa2aWiAPWzCwRB6yZWSIOWDOzRBywZmaJOGDNRphx48YhqaEH0FC/cePGtfmrGpzadTctK0DvL0ijfFOPkWHNmjUN/6wbvTlQs/vaSOGAHcaq/RL57khmxfEUgZlZIg5YM7NEHLBmZok4YM3MEnHAmpkl4oA1M0vEAWtmlogD1swsEQesmVkiDlgzs0QcsGZmiThgzcwSccCamSXiu2mZjTDxzW1hznYN9e0CKDW4TtuMA9ZshNG5a5PcDzbmDKyu4chTBGZmiThgzcwSccCamSXigDUzS8QBa2aWiAPWzCwRB6yZWSIOWDOzRBywZmaJOGDNzBIpLGAlLZcUVR4La4zZVdJPJa2T9KKkSyWNKapmM7OBKPJeBPsDo8ueTwCWAjdU6yxpNLAQeAn4KPAnwDxAwMlJKzUza4HCAjYiVpc/lzQTWAvc2MeQw4D3AbtFxG/zMWcAcyWdHRFrU9ZrZjZQbZmDlSRgJnBdRKzvo9uHgWW94Zq7DdgK+GDiEs3MBqxdJ7kOBXYH5tbosxPwu4q2F4FN+TIzs0GtXfeD/QqwJCIeqNOvr5tW9nkzS0mzgFkAHR0dlEqlfhU4nPl7Yo3uAz09PQ339X61OTV6492WbVDaEXgWOCkirq7R71vAZyLifWVtOwCrgEMiYlG9bXV2dkZ3d3cLqh4+JDV8s2UbnprZB5q64fYI2q8kLY2Iznr92jFFMAPYAMyv0+9uYKqkncvaDs3HLk1TmplZ6xQasPnJreOB+RHxWsWy2ZIeL2v6D+BR4IeS9pX0ceAfgat9BYGZDQVFH8F2AXsB1aYGxgNTep9ExCbgSGA9sBhYANwEnJ68SjOzFij0JFc+b6o+ls0B5lS0PQN8MnlhZmYJ+F4EZmaJOGDNzBJxwJqZJeKANTNLxAFrZpaIA9bMLBEHrJlZIg5YM7NEHLBmZok4YM3MEnHAmpkl4oA1M0vEAWtmlogD1swsEQesmVkiDlgzs0QcsGZmiThgzcwSKfQjY8xscMg+f7R1tt9++5aub7hwwJqNMBHRcF9JTfW3t/MUgZlZIg5YM7NEHLBmZok4YM3MEnHAmpkl4oA1M0vEATtMjBs3Dkl1H0BD/SQxbty4Nn9VZkObA3aYWLNmDRFR97Fo0aKG+kUEa9asafeXZTakOWDNzBJxwJqZJeKANTNLxAFrZpaIA9bMLBEHrJlZIg5YM7NECg1YSRMkzZO0WtIbkh6TdFCdMdMlPSBpvaQVkr5WVL1mZgNR2A23JY0FFgN3AkcCq4FJwKoaYz4B/BtwCnArMBW4WtLrEXFZ8qLNzAagyE80OANYGRHHlbU9XWfMscBPI+KK/PlTki4AzpR0efhW62Y2iBU5RXA0cI+kBZJW5S/7Z6v2hwNtBbxR0fY6sDOwW6pCzcxaociAnQScCDwFHA5cAlwInFRjzG3A0ZIOkzRK0mTgtHzZhJTFmpkNVJFTBKOA7og4K39+v6S9yAK2r/nUq4E9gFuALYG1ZME8B9hUbYCkWcAsgI6ODkqlUovKH/wa+Vp7enqa+p6MpO+fVed9oP9U1DSmpBXA/4mI48vajgWujIht6owdDexEdmLsY8DPgI6I6PMEGUBnZ2d0d3cPuPahoNFP/yyVSnR1dbV0nTZ8eR+oTtLSiOis16/II9jFwJSKtsnAinoDI2IT8ByApM8Bd9cLVzOzdisyYC8G7pJ0NrAA2Jfs8quv93bIrxD4UER8LH8+HjgGKJGd8PpS/rzmtbNmZoNBYSe5ImIJ2ZUE04FHgPOAc4AryrpNIJtzLXccsITsCPh9QFdE3Ju8YDOzASryCJaIWAgsrLF8RsXzF4EPJy7LzCwJ34vAzCwRB6yZWSIOWDOzRPo1BytpayrCOSLWt6QiM7NhouEjWEm7SbpF0lpgHfBaxcPMzMo0cwR7HbA1cDLwO8Bv7zAzq6GZgN0X2D8ilqUqxsxsOGnmJNeDwA6pCjEzG26aOYKdBVwq6VKyd2L9vnxhRDzTysLMzIa6ZgJ2FLAj8GPePv+q/PnoFtZlZjbkNROw88huF/gpfJLLzKyuZgL2vcA+EfFkqmLMzIaTZk5y3QvsnqoQM7Phppkj2H8BvivpIuBhNj/JdV8rCzMzG+oa/sgYSW/VWBwRMehOco2kj4xhznaJ1vtqmvXakOCPjKkuxUfGeHpgENO5a9N8JtecgdVlNpI1HLARsULSTsCBZJdrlc/fBtkUgpkNUZIabvdRbWMaDlhJXwTmkl33uoa3X6blgDUb4qqFZjOveGxzzUwRnAd8B/hWRLyZqB4zs2Gjmcu0tgWudbiamTWmmYD9EXBkqkLMzIabZqYI/ga4WdLHqH4d7LdaWZiZ2VDXTMCeAEwDXgT2ZPOTXA5YM7MyzQTsOcBpEXFxqmLMzIaTZuZgRwM/SVWImdlw00zA/gD4QqpCzMyGm2amCN4JHC/pcOAhNj/JdUorCzMzG+qaCdipwP35/99bsczvmzMzq9DMvQgOTlmImdlw08wcrJmZNcEBa2aWiAPWzCwRB6yZWSIOWDOzRBywZmaJFBqwkiZImidptaQ3JD0m6aA6Yw6XdLek1yS9KOkWSZOLqtnMrL8KC1hJY4HFZB85cyTZGxdOBlbVGLM7cAvwf4F9gY8D7wB+lrpeM7OBauadXAN1BrAyIo4ra3u6zpgPAlsCZ0XEJgBJFwB3SBofES+mKdXMbOCKnCI4GrhH0gJJqyQ9IGm2+vooy0w32T0Pjpc0WtK7gL8CljhczWywK/IIdhJwInAxcCGwD/C9fNll1QZExHJJhwI3ApeT/UG4H/hEXxuRNAuYBdDR0UGpVGpR+YNfI19rT09PU9+TkfT9s801u7/Y26mozzeXtBHojogDy9rOBz4dEVP7GLMT8EvgZuB64F388ZMTDomIt2pts7OzM7q7u1tR/qAnqaHPqm/mY5gbXacNX/7Y7uokLY2Iznr9ijyCXQk8VtG2DDi1xpiTgHURcUZvg6QvAr8FDgTubHWRZmatUuQc7GJgSkXbZGBFjTHvBDZVtPU+9zW8ZjaoFRlSFwMHSDpb0p6SjgFOIZtbBbIrBCTdXjZmIbCfpG9K2kvSfmSfrPBbYGmBtZuZNa2wgI2IJWRXEkwHHgHOI/sgxSvKuk0A9igbcwfweeAospNbt5FdVTAtItYVU7mZWf8UOQdLRCwkOyrta/mMKm3zgfkJyzIzS8LzmGZmiThgzcwSccCamSXigDUzS8QBa2aWiAPWzCwRB6yZWSIOWDOzRBywZmaJOGDNzBJxwJqZJeKANTNLxAFrZpaIA9bMLBEHrJlZIg5YM7NEHLBmZok4YM3MEnHAmpkl4oA1M0vEAWtmlogD1swsEQesmVkiDlgzs0QcsGZmiThgzcwSccCamSXigDUzS8QBa2aWyBbtLsBaR1JL17f99tu3dH1mI40DdpiIiIb6SWq4r5kNjKcIzMwSccCamSXigDUzS8QBa2aWSKEBK2mCpHmSVkt6Q9Jjkg6q0X+OpOjjsWORtZuZNauwqwgkjQUWA3cCRwKrgUnAqhrD/gm4sqJtPhARUWucmVnbFXmZ1hnAyog4rqzt6VoDIqIH6Ol9LmkX4KPAsUkqNDNroSKnCI4G7pG0QNIqSQ9Imq3mro6fCbwC/O80JZqZtU6RR7CTgBOBi4ELgX2A7+XLLqs3WNIo4MvADyNiQ41+s4BZAB0dHZRKpYFVPQz5e2KN6unp8f4yACrqXT2SNgLdEXFgWdv5wKcjYmoD448E/h14f0Q82sg2Ozs7o7u7u78lD0t+J5c1o1Qq0dXV1e4yBh1JSyOis16/IqcIVgKPVbQtA3ZtcPws4K5Gw9XMrN2KnCJYDEypaJsMrKg3UNK7ya48OD5BXWZmSRR5BHsxcICksyXtKekY4BTg8t4Oki6QdHuVsV8G1gE3FFOqmdnAFRawEbGE7EqC6cAjwHnAOcAVZd0mAHuUj8uvMpgJ/Cgi1hdTrZnZwBV6u8KIWAgsrLF8RpW2AHZPWJaZWRK+F4GZWSIOWDOzRBywZmaJOGDNzBJxwJqZJeKANTNLxAFrZpaIA9bMLBEHrJlZIg5YM7NEHLBmZok4YM3MEnHAmpkl4oA1M0vEAWtmlogD1swsEQesmVkiDlgzs0QcsGZmiThgzcwSccCamSXigDUzS8QBa2aWiAPWzCwRB6yZWSIOWDOzRBywZmaJOGDNzBJxwJqZJeKANTNLxAFrZpaIA9bMLBEHrJlZIg5YM7NEHLBmZokUGrCSJkiaJ2m1pDckPSbpoDpjJOmrkh6XtEHSSkkXFlWzmVl/bVHUhiSNBRYDdwJHAquBScCqOkMvAj4JfA14GNgOmJCuUjOz1igsYIEzgJURcVxZ29O1BkiaApwM7B0Ry8oW3Z+gPjOzlipyiuBo4B5JCyStkvSApNmSVGPMUcBTwDRJT0lank8x7FhMyWZm/VfkEewk4ETgYuBCYB/ge/myy2qM2Q34LDADCOCfgJ9K+nBEvFU5QNIsYBZAR0cHpVKpdV/BMOHviTWqp6fH+8sAKCKK2ZC0EeiOiAPL2s4HPh0RU/sYcxXwFWBKRDyZt00GngAOiIh7am2zs7Mzuru7W/UlDAuSKOpnbkNfqVSiq6ur3WUMOpKWRkRnvX5FThGsBB6raFsG7FpnzJu94Zr7FfBmnXFmZm1XZMAuBqZUtE0GVtQZs4WkPcraJpFNbdQaZ2bWdkUG7MXAAZLOlrSnpGOAU4DLeztIukDS7WVjfgHcB1wjaV9J+wLXAPcAfu1vZoNaYQEbEUvIriSYDjwCnAecA1xR1m0CsEfZmLfIroFdBfwSuA14Fjiq2gkueztJmz36aq99MYeZ9UeRVxEQEQuBhTWWz6jSthI4JmFZw1a1k1k+aWFWHN+LwMwsEQesmVkiDlgzs0QcsGZmiThgzcwSccCamSXigDUzS8QBa2aWiAPWzCwRB6yZWSIOWDOzRAq74XY7SFqNb2tYaTzwYruLsCHD+0t1u0XEDvU6DeuAtc1J6m7kTuxm4P1loDxFYGaWiAPWzCwRB+zIc1W7C7AhxfvLAHgO1swsER/Bmpkl4oAdwSSVJF3W7jqs/yp/ho38TCU9ImlO8uLMATuYSOqQdImk30jaIOk5ST+XdESiTf4lcFaidVuDJP21pHWSxpS1jZG0XtLDFX33khSSDsmbWvozzAM6ajyWt2pbI0GhH3pofZM0EVgMvEb2C/Mg2R/AjwFXArv2Y52jyObZN1W0j4mIjRHx8gDLRtKWEfH7ga5nhLsDeCfwIeDOvO2/Aq8CkyXtEBGr8/YuYANwF0ArfoYV/hLoDfpxwKPAZ3q3B2yqNsiq8xHs4HEFIKAzIm6IiCciYllEXAZ8AEDS30h6KD/aeU7SXElje1cgaYakHklHSHoE2AhMlXStpH+XdKakZ8k++rzay8sxkr4t6dl8G0skHV62vCs/ijlC0r2SNgKHS9pF0i2SXs6Puh6X9NlCvmvDQEQ8CTwPHFzWfDDwC6CbLFTL2++OiDeg/pSApB3zn83rklZI+nKdWl6OiBci4gVgVd78h7aIWC3pfEndVba1VNJ38v/Pl/S/JJ0raZWktZKukrRVWf9Rks6W9HRe30OSppctl6S/l/RM/orueUlza9U/2PgIdhCQNA6YBvxdRPRULo+INfl/3wK+CjwF7AZ8L38cW9Z9a+DvgBOA1cDKvP0gsiOiaWRBXs0PgD2Az5OF8BHATyXtHxEPlvX7NnAa8GuyI+5r8u0eDKwFpjT4pdsfLSL7/v19/vxg4Drgmfz/N+btXWSvaBp1Ldm+8nFgPXAxMHGAtc4F/lbS3hHxEICkvYH9gC+U9Tuc7Gj74LyGa4BXgDPy5f9Itj+eAPwK+HNgnqSXI+IXZPvhScDngGVABzC03lUWEX60+UH20jCATzc5bhrZDjwqfz4jX88HK/pdSxa2W1W0l4DL8v/vQRbgu1b0uRm4Iv9/V77+z1T0eQj4Zru/j0P5AcwEXge2Ivtj9Xr+MzkMWJb3eW/+/f+zaj/DKj/TyXn/j5Qt343sZf6cBmoan4/vqrLsF8B3y55fAtxZ9nx+vs9tXdZ2PFnIjwHGkr3C2r9ivVcCN+X//zrwMDC63T+f/j58BDs49HVE+fZO2YmNs4CpwHbAaLKddSeyl5gAbwIPVBn+SERsqLH6/fI6HpPeVs5WZHOE5SpfHl4CXClpGnA78OOIWFr3C7Jyi8iC9cNkP4cXI+I3kl4A9pC0E9mR4HrgngbXOZXsj+a9vQ0RsULS830PadjVwGWSeo9GvwB8raLP/ZFPZeTuBt5BdgTdAWwJLKrY37YEHs//P5/sCPZpSbcBtwI/iSE05++AHRx+RXakMBX4cbUOknYDFpLt2N8AXiILxev540kJgA1RcVIrt65ODaPyGvYHKnfg12utKyL+Nf8FOILspehdki6IiDl1tmm5iHhK0gqyVwkiOxIlItZJWpq3d5EdJTYaMA394e6nHwOXA3+Rb2cr4IYmxvee/5kGvFCxbCP84XuyJ3Ao2cneS4GzJR1YEdyDlk9yDQKRnQm+DZgt6b9ULs9PZHWSBen/iIi7Izsx8u4WlnE/2S/KThHx64rHcw18Dc9GxFURMZ3sD8CsFtY2UvTOwx5MHrC5EnAIWcBWvpqoZRnZ7/j+vQ2SdqUF+01EbAR+CHw5fyyIiMo/4vuUn9QCDiD7Y72c7KX/m8AuVfa3Z8q283pE/CQiTgUOBPYlm1IbEnwEO3icSHYpTLekc8jmNUX2y3YW8EmyX5avSrqJbGf9aqs2HhFPSvoRcK2k04D7yC7T6QKeioib+hor6RLg58CTwLZkRyWPtaq2EWQR2YkdgC+Vtf8n2dHhu/I+DYmIJyTdCnxf0iyycPtnNn9F0l9XkwWlgD+rsvwdwFxJF5DN/f4D2Xz+RuDlfL+5RNKWZJcobksWoq9HxDWSvkIWwkvIXjUdS3Z0+5sW1Z+cA3aQiIinJe1HNrH/beA9ZNMADwInRMRDkk4FziTbUe8CTgcWtLCMLwFnA98BdgZeJpu/q/dLPYrsaoZdyK4quJ3sKgNrziKyVynPRkR5iNxJFlZrgWbntmeQBeEdZDfOPhfYccCVAhGxTNK9wNiIuLtKl9vIbnj/S7IphAVkV7j0OoPs3MHXgUlkVxjcD1yYL3+FbB//Ltn5hkeBoxp5RTVY+GYvZtYvys5O/ZrsqPSiimXzgS0i4r+1pbhBwkewZtY0SR3AX5EdDf9rm8sZtBywZtYUSVuTnflfDRwfEa+0uaRBy1MEZmaJ+DItM7NEHLBmZok4YM3MEnHAmpkl4oA1M0vEAWtmlsj/B3CfP2O/2nGNAAAAAElFTkSuQmCC\n",
      "text/plain": [
       "<Figure size 360x360 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "g1 = df.index[df['GroupId'] < 0].tolist()\n",
    "g2 = df.index[df['GroupId'] > 0].tolist()\n",
    "\n",
    "centroid_sizes = []\n",
    "for method in (m_rigid,):\n",
    "    for groupid in (g2, g1):\n",
    "        datasets = [method.GetBlock(idx) for idx in groupid]\n",
    "        centroid_sizes.append([centroid_size(vtk_to_numpy(d)) for d in datasets])\n",
    "\n",
    "labels = ('Carriers', 'Wild Types') \n",
    "\n",
    "font = {'weight' : 'normal',\n",
    "        'size'   : 14}\n",
    "\n",
    "plt.rc('font', **font)\n",
    "\n",
    "fig = plt.figure(figsize=[5,5])\n",
    "ax = fig.add_subplot(1,1,1)\n",
    "ax.grid(which='major', axis='both')\n",
    "ax.boxplot(centroid_sizes, labels=labels)\n",
    "ax.set_title('Craniums')\n",
    "ax.set_ylabel('mm')\n",
    "# ax.set_ylim((3,8))\n",
    "plt.savefig(os.path.join(working_directory, 'centroid-size lmb.pdf'))\n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "raw",
   "metadata": {},
   "source": [
    "centroid_sizes"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 132,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[[6.69850039903587,\n",
       "  6.661563264135345,\n",
       "  6.9354392506938645,\n",
       "  6.5885233078557155,\n",
       "  6.88443959628176,\n",
       "  6.938165542208045,\n",
       "  6.916859358155702,\n",
       "  6.825226147302115,\n",
       "  6.796492487421158,\n",
       "  7.069575525577299],\n",
       " [7.057890519007956,\n",
       "  7.015212828655567,\n",
       "  6.996540641720139,\n",
       "  6.918939268127656,\n",
       "  6.850776573474887,\n",
       "  6.931491292658292,\n",
       "  7.073771283304273,\n",
       "  7.127479169763626,\n",
       "  7.103535573942651,\n",
       "  7.061296793839985]]"
      ]
     },
     "execution_count": 132,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "centroid_sizes"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.8"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
